{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs3/core-js-stable/reflect/construct\");\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnsetOp = exports.SetOp = exports.RemoveOp = exports.RelationOp = exports.Op = exports.IncrementOp = exports.AddUniqueOp = exports.AddOp = void 0;\nexports.opFromJSON = opFromJSON;\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/assertThisInitialized\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _arrayContainsObject = _interopRequireDefault(require(\"./arrayContainsObject\"));\nvar _decode = _interopRequireDefault(require(\"./decode\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\nvar _unique = _interopRequireDefault(require(\"./unique\"));\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function () {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction opFromJSON(json\n/*: { [key: string]: any }*/) /*: ?Op*/\n{\n  if (!json || !json.__op) {\n    return null;\n  }\n  switch (json.__op) {\n    case 'Delete':\n      return new UnsetOp();\n    case 'Increment':\n      return new IncrementOp(json.amount);\n    case 'Add':\n      return new AddOp((0, _decode.default)(json.objects));\n    case 'AddUnique':\n      return new AddUniqueOp((0, _decode.default)(json.objects));\n    case 'Remove':\n      return new RemoveOp((0, _decode.default)(json.objects));\n    case 'AddRelation':\n      {\n        var toAdd = (0, _decode.default)(json.objects);\n        if (!(0, _isArray.default)(toAdd)) {\n          return new RelationOp([], []);\n        }\n        return new RelationOp(toAdd, []);\n      }\n    case 'RemoveRelation':\n      {\n        var toRemove = (0, _decode.default)(json.objects);\n        if (!(0, _isArray.default)(toRemove)) {\n          return new RelationOp([], []);\n        }\n        return new RelationOp([], toRemove);\n      }\n    case 'Batch':\n      {\n        var _toAdd = [];\n        var _toRemove = [];\n        for (var i = 0; i < json.ops.length; i++) {\n          if (json.ops[i].__op === 'AddRelation') {\n            _toAdd = (0, _concat.default)(_toAdd).call(_toAdd, (0, _decode.default)(json.ops[i].objects));\n          } else if (json.ops[i].__op === 'RemoveRelation') {\n            _toRemove = (0, _concat.default)(_toRemove).call(_toRemove, (0, _decode.default)(json.ops[i].objects));\n          }\n        }\n        return new RelationOp(_toAdd, _toRemove);\n      }\n    default:\n      return null;\n  }\n}\nvar Op = /*#__PURE__*/function () {\n  function Op() {\n    (0, _classCallCheck2.default)(this, Op);\n  }\n  (0, _createClass2.default)(Op, [{\n    key: \"applyTo\",\n    value:\n    // Empty parent class\n    function () /*: mixed*/\n    {}\n    /* eslint-disable-line no-unused-vars */\n  }, {\n    key: \"mergeWith\",\n    value: function () /*: ?Op*/\n    {}\n    /* eslint-disable-line no-unused-vars */\n  }, {\n    key: \"toJSON\",\n    value: function () /*: mixed*/\n    {}\n  }]);\n  return Op;\n}();\nexports.Op = Op;\nvar SetOp = /*#__PURE__*/function (_Op) {\n  (0, _inherits2.default)(SetOp, _Op);\n  var _super = _createSuper(SetOp);\n  function SetOp(value\n  /*: mixed*/) {\n    var _this;\n    (0, _classCallCheck2.default)(this, SetOp);\n    _this = _super.call(this);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"_value\", void 0);\n    _this._value = value;\n    return _this;\n  }\n  (0, _createClass2.default)(SetOp, [{\n    key: \"applyTo\",\n    value: function () /*: mixed*/\n    {\n      return this._value;\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function () /*: SetOp*/\n    {\n      return new SetOp(this._value);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function (offline\n    /*:: ?: boolean*/) {\n      return (0, _encode.default)(this._value, false, true, undefined, offline);\n    }\n  }]);\n  return SetOp;\n}(Op);\nexports.SetOp = SetOp;\nvar UnsetOp = /*#__PURE__*/function (_Op2) {\n  (0, _inherits2.default)(UnsetOp, _Op2);\n  var _super2 = _createSuper(UnsetOp);\n  function UnsetOp() {\n    (0, _classCallCheck2.default)(this, UnsetOp);\n    return _super2.apply(this, arguments);\n  }\n  (0, _createClass2.default)(UnsetOp, [{\n    key: \"applyTo\",\n    value: function () {\n      return undefined;\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function () /*: UnsetOp*/\n    {\n      return new UnsetOp();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function () /*: { __op: string }*/\n    {\n      return {\n        __op: 'Delete'\n      };\n    }\n  }]);\n  return UnsetOp;\n}(Op);\nexports.UnsetOp = UnsetOp;\nvar IncrementOp = /*#__PURE__*/function (_Op3) {\n  (0, _inherits2.default)(IncrementOp, _Op3);\n  var _super3 = _createSuper(IncrementOp);\n  function IncrementOp(amount\n  /*: number*/) {\n    var _this2;\n    (0, _classCallCheck2.default)(this, IncrementOp);\n    _this2 = _super3.call(this);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), \"_amount\", void 0);\n    if (typeof amount !== 'number') {\n      throw new TypeError('Increment Op must be initialized with a numeric amount.');\n    }\n    _this2._amount = amount;\n    return _this2;\n  }\n  (0, _createClass2.default)(IncrementOp, [{\n    key: \"applyTo\",\n    value: function (value\n    /*: ?mixed*/) /*: number*/\n    {\n      if (typeof value === 'undefined') {\n        return this._amount;\n      }\n      if (typeof value !== 'number') {\n        throw new TypeError('Cannot increment a non-numeric value.');\n      }\n      return this._amount + value;\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/) /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      }\n      if (previous instanceof SetOp) {\n        return new SetOp(this.applyTo(previous._value));\n      }\n      if (previous instanceof UnsetOp) {\n        return new SetOp(this._amount);\n      }\n      if (previous instanceof IncrementOp) {\n        return new IncrementOp(this.applyTo(previous._amount));\n      }\n      throw new Error('Cannot merge Increment Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function () /*: { __op: string, amount: number }*/\n    {\n      return {\n        __op: 'Increment',\n        amount: this._amount\n      };\n    }\n  }]);\n  return IncrementOp;\n}(Op);\nexports.IncrementOp = IncrementOp;\nvar AddOp = /*#__PURE__*/function (_Op4) {\n  (0, _inherits2.default)(AddOp, _Op4);\n  var _super4 = _createSuper(AddOp);\n  function AddOp(value\n  /*: mixed | Array<mixed>*/) {\n    var _this3;\n    (0, _classCallCheck2.default)(this, AddOp);\n    _this3 = _super4.call(this);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), \"_value\", void 0);\n    _this3._value = (0, _isArray.default)(value) ? value : [value];\n    return _this3;\n  }\n  (0, _createClass2.default)(AddOp, [{\n    key: \"applyTo\",\n    value: function (value\n    /*: mixed*/) /*: Array<mixed>*/\n    {\n      if (value == null) {\n        return this._value;\n      }\n      if ((0, _isArray.default)(value)) {\n        return (0, _concat.default)(value).call(value, this._value);\n      }\n      throw new Error('Cannot add elements to a non-array value');\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/) /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      }\n      if (previous instanceof SetOp) {\n        return new SetOp(this.applyTo(previous._value));\n      }\n      if (previous instanceof UnsetOp) {\n        return new SetOp(this._value);\n      }\n      if (previous instanceof AddOp) {\n        return new AddOp(this.applyTo(previous._value));\n      }\n      throw new Error('Cannot merge Add Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function () /*: { __op: string, objects: mixed }*/\n    {\n      return {\n        __op: 'Add',\n        objects: (0, _encode.default)(this._value, false, true)\n      };\n    }\n  }]);\n  return AddOp;\n}(Op);\nexports.AddOp = AddOp;\nvar AddUniqueOp = /*#__PURE__*/function (_Op5) {\n  (0, _inherits2.default)(AddUniqueOp, _Op5);\n  var _super5 = _createSuper(AddUniqueOp);\n  function AddUniqueOp(value\n  /*: mixed | Array<mixed>*/) {\n    var _this4;\n    (0, _classCallCheck2.default)(this, AddUniqueOp);\n    _this4 = _super5.call(this);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), \"_value\", void 0);\n    _this4._value = (0, _unique.default)((0, _isArray.default)(value) ? value : [value]);\n    return _this4;\n  }\n  (0, _createClass2.default)(AddUniqueOp, [{\n    key: \"applyTo\",\n    value: function (value\n    /*: mixed | Array<mixed>*/) /*: Array<mixed>*/\n    {\n      if (value == null) {\n        return this._value || [];\n      }\n      if ((0, _isArray.default)(value)) {\n        var _context;\n        var toAdd = [];\n        (0, _forEach.default)(_context = this._value).call(_context, function (v) {\n          if (v instanceof _ParseObject.default) {\n            if (!(0, _arrayContainsObject.default)(value, v)) {\n              toAdd.push(v);\n            }\n          } else {\n            if ((0, _indexOf.default)(value).call(value, v) < 0) {\n              toAdd.push(v);\n            }\n          }\n        });\n        return (0, _concat.default)(value).call(value, toAdd);\n      }\n      throw new Error('Cannot add elements to a non-array value');\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/) /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      }\n      if (previous instanceof SetOp) {\n        return new SetOp(this.applyTo(previous._value));\n      }\n      if (previous instanceof UnsetOp) {\n        return new SetOp(this._value);\n      }\n      if (previous instanceof AddUniqueOp) {\n        return new AddUniqueOp(this.applyTo(previous._value));\n      }\n      throw new Error('Cannot merge AddUnique Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function () /*: { __op: string, objects: mixed }*/\n    {\n      return {\n        __op: 'AddUnique',\n        objects: (0, _encode.default)(this._value, false, true)\n      };\n    }\n  }]);\n  return AddUniqueOp;\n}(Op);\nexports.AddUniqueOp = AddUniqueOp;\nvar RemoveOp = /*#__PURE__*/function (_Op6) {\n  (0, _inherits2.default)(RemoveOp, _Op6);\n  var _super6 = _createSuper(RemoveOp);\n  function RemoveOp(value\n  /*: mixed | Array<mixed>*/) {\n    var _this5;\n    (0, _classCallCheck2.default)(this, RemoveOp);\n    _this5 = _super6.call(this);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), \"_value\", void 0);\n    _this5._value = (0, _unique.default)((0, _isArray.default)(value) ? value : [value]);\n    return _this5;\n  }\n  (0, _createClass2.default)(RemoveOp, [{\n    key: \"applyTo\",\n    value: function (value\n    /*: mixed | Array<mixed>*/) /*: Array<mixed>*/\n    {\n      if (value == null) {\n        return [];\n      }\n      if ((0, _isArray.default)(value)) {\n        // var i = value.indexOf(this._value);\n        var removed = (0, _concat.default)(value).call(value, []);\n        for (var i = 0; i < this._value.length; i++) {\n          var index = (0, _indexOf.default)(removed).call(removed, this._value[i]);\n          while (index > -1) {\n            (0, _splice.default)(removed).call(removed, index, 1);\n            index = (0, _indexOf.default)(removed).call(removed, this._value[i]);\n          }\n          if (this._value[i] instanceof _ParseObject.default && this._value[i].id) {\n            for (var j = 0; j < removed.length; j++) {\n              if (removed[j] instanceof _ParseObject.default && this._value[i].id === removed[j].id) {\n                (0, _splice.default)(removed).call(removed, j, 1);\n                j--;\n              }\n            }\n          }\n        }\n        return removed;\n      }\n      throw new Error('Cannot remove elements from a non-array value');\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/) /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      }\n      if (previous instanceof SetOp) {\n        return new SetOp(this.applyTo(previous._value));\n      }\n      if (previous instanceof UnsetOp) {\n        return new UnsetOp();\n      }\n      if (previous instanceof RemoveOp) {\n        var _context2;\n        var uniques = (0, _concat.default)(_context2 = previous._value).call(_context2, []);\n        for (var i = 0; i < this._value.length; i++) {\n          if (this._value[i] instanceof _ParseObject.default) {\n            if (!(0, _arrayContainsObject.default)(uniques, this._value[i])) {\n              uniques.push(this._value[i]);\n            }\n          } else {\n            if ((0, _indexOf.default)(uniques).call(uniques, this._value[i]) < 0) {\n              uniques.push(this._value[i]);\n            }\n          }\n        }\n        return new RemoveOp(uniques);\n      }\n      throw new Error('Cannot merge Remove Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function () /*: { __op: string, objects: mixed }*/\n    {\n      return {\n        __op: 'Remove',\n        objects: (0, _encode.default)(this._value, false, true)\n      };\n    }\n  }]);\n  return RemoveOp;\n}(Op);\nexports.RemoveOp = RemoveOp;\nvar RelationOp = /*#__PURE__*/function (_Op7) {\n  (0, _inherits2.default)(RelationOp, _Op7);\n  var _super7 = _createSuper(RelationOp);\n  function RelationOp(adds\n  /*: Array<ParseObject | string>*/, removes\n  /*: Array<ParseObject | string>*/) {\n    var _this6;\n    (0, _classCallCheck2.default)(this, RelationOp);\n    _this6 = _super7.call(this);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"_targetClassName\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"relationsToAdd\", void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), \"relationsToRemove\", void 0);\n    _this6._targetClassName = null;\n    if ((0, _isArray.default)(adds)) {\n      _this6.relationsToAdd = (0, _unique.default)((0, _map.default)(adds).call(adds, _this6._extractId, (0, _assertThisInitialized2.default)(_this6)));\n    }\n    if ((0, _isArray.default)(removes)) {\n      _this6.relationsToRemove = (0, _unique.default)((0, _map.default)(removes).call(removes, _this6._extractId, (0, _assertThisInitialized2.default)(_this6)));\n    }\n    return _this6;\n  }\n  (0, _createClass2.default)(RelationOp, [{\n    key: \"_extractId\",\n    value: function (obj\n    /*: string | ParseObject*/) /*: string*/\n    {\n      if (typeof obj === 'string') {\n        return obj;\n      }\n      if (!obj.id) {\n        throw new Error('You cannot add or remove an unsaved Parse Object from a relation');\n      }\n      if (!this._targetClassName) {\n        this._targetClassName = obj.className;\n      }\n      if (this._targetClassName !== obj.className) {\n        var _context3;\n        throw new Error((0, _concat.default)(_context3 = \"Tried to create a Relation with 2 different object types: \".concat(this._targetClassName, \" and \")).call(_context3, obj.className, \".\"));\n      }\n      return obj.id;\n    }\n  }, {\n    key: \"applyTo\",\n    value: function (value\n    /*: mixed*/, object\n    /*:: ?: { className: string, id: ?string }*/, key\n    /*:: ?: string*/) /*: ?ParseRelation*/\n    {\n      if (!value) {\n        var _context4;\n        if (!object || !key) {\n          throw new Error('Cannot apply a RelationOp without either a previous value, or an object and a key');\n        }\n        var parent = new _ParseObject.default(object.className);\n        if (object.id && (0, _indexOf.default)(_context4 = object.id).call(_context4, 'local') === 0) {\n          parent._localId = object.id;\n        } else if (object.id) {\n          parent.id = object.id;\n        }\n        var relation = new _ParseRelation.default(parent, key);\n        relation.targetClassName = this._targetClassName;\n        return relation;\n      }\n      if (value instanceof _ParseRelation.default) {\n        if (this._targetClassName) {\n          if (value.targetClassName) {\n            if (this._targetClassName !== value.targetClassName) {\n              var _context5;\n              throw new Error((0, _concat.default)(_context5 = \"Related object must be a \".concat(value.targetClassName, \", but a \")).call(_context5, this._targetClassName, \" was passed in.\"));\n            }\n          } else {\n            value.targetClassName = this._targetClassName;\n          }\n        }\n        return value;\n      }\n      throw new Error('Relation cannot be applied to a non-relation field');\n    }\n  }, {\n    key: \"mergeWith\",\n    value: function (previous\n    /*: Op*/) /*: Op*/\n    {\n      if (!previous) {\n        return this;\n      }\n      if (previous instanceof UnsetOp) {\n        throw new Error('You cannot modify a relation after deleting it.');\n      }\n      if (previous instanceof SetOp && previous._value instanceof _ParseRelation.default) {\n        return this;\n      }\n      if (previous instanceof RelationOp) {\n        var _context7, _context8, _context9, _context10, _context11, _context12;\n        if (previous._targetClassName && previous._targetClassName !== this._targetClassName) {\n          var _context6;\n          throw new Error((0, _concat.default)(_context6 = \"Related object must be of class \".concat(previous._targetClassName, \", but \")).call(_context6, this._targetClassName || 'null', \" was passed in.\"));\n        }\n        var newAdd = (0, _concat.default)(_context7 = previous.relationsToAdd).call(_context7, []);\n        (0, _forEach.default)(_context8 = this.relationsToRemove).call(_context8, function (r) {\n          var index = (0, _indexOf.default)(newAdd).call(newAdd, r);\n          if (index > -1) {\n            (0, _splice.default)(newAdd).call(newAdd, index, 1);\n          }\n        });\n        (0, _forEach.default)(_context9 = this.relationsToAdd).call(_context9, function (r) {\n          var index = (0, _indexOf.default)(newAdd).call(newAdd, r);\n          if (index < 0) {\n            newAdd.push(r);\n          }\n        });\n        var newRemove = (0, _concat.default)(_context10 = previous.relationsToRemove).call(_context10, []);\n        (0, _forEach.default)(_context11 = this.relationsToAdd).call(_context11, function (r) {\n          var index = (0, _indexOf.default)(newRemove).call(newRemove, r);\n          if (index > -1) {\n            (0, _splice.default)(newRemove).call(newRemove, index, 1);\n          }\n        });\n        (0, _forEach.default)(_context12 = this.relationsToRemove).call(_context12, function (r) {\n          var index = (0, _indexOf.default)(newRemove).call(newRemove, r);\n          if (index < 0) {\n            newRemove.push(r);\n          }\n        });\n        var newRelation = new RelationOp(newAdd, newRemove);\n        newRelation._targetClassName = this._targetClassName;\n        return newRelation;\n      }\n      throw new Error('Cannot merge Relation Op with the previous Op');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function () /*: { __op?: string, objects?: mixed, ops?: mixed }*/\n    {\n      var _this7 = this;\n      var idToPointer = function (id) {\n        return {\n          __type: 'Pointer',\n          className: _this7._targetClassName,\n          objectId: id\n        };\n      };\n      var adds = null;\n      var removes = null;\n      var pointers = null;\n      if (this.relationsToAdd.length > 0) {\n        var _context13;\n        pointers = (0, _map.default)(_context13 = this.relationsToAdd).call(_context13, idToPointer);\n        adds = {\n          __op: 'AddRelation',\n          objects: pointers\n        };\n      }\n      if (this.relationsToRemove.length > 0) {\n        var _context14;\n        pointers = (0, _map.default)(_context14 = this.relationsToRemove).call(_context14, idToPointer);\n        removes = {\n          __op: 'RemoveRelation',\n          objects: pointers\n        };\n      }\n      if (adds && removes) {\n        return {\n          __op: 'Batch',\n          ops: [adds, removes]\n        };\n      }\n      return adds || removes || {};\n    }\n  }]);\n  return RelationOp;\n}(Op);\nexports.RelationOp = RelationOp;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}