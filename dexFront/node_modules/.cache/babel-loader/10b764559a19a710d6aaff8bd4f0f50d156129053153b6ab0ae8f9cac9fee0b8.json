{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNodeFromCompactMultiProof = exports.createCompactMultiProof = exports.compactMultiProofToNode = exports.nodeToCompactMultiProof = exports.descriptorToBitlist = exports.computeDescriptor = void 0;\nconst gindex_1 = require(\"../gindex\");\nconst node_1 = require(\"../node\");\nconst util_1 = require(\"./util\");\nfunction computeDescriptor(indices) {\n  // include all helper indices\n  const proofBitstrings = new Set();\n  const pathBitstrings = new Set();\n  for (const leafIndex of indices) {\n    const leafBitstring = gindex_1.convertGindexToBitstring(leafIndex);\n    proofBitstrings.add(leafBitstring);\n    const {\n      branch,\n      path\n    } = util_1.computeProofBitstrings(leafBitstring);\n    path.delete(leafBitstring);\n    for (const pathIndex of path) {\n      pathBitstrings.add(pathIndex);\n    }\n    for (const branchIndex of branch) {\n      proofBitstrings.add(branchIndex);\n    }\n  }\n  for (const pathIndex of pathBitstrings) {\n    proofBitstrings.delete(pathIndex);\n  }\n  // sort gindex bitstrings in-order\n  const allBitstringsSorted = Array.from(proofBitstrings).sort((a, b) => a.localeCompare(b));\n  // convert gindex bitstrings into descriptor bitstring\n  let descriptorBitstring = \"\";\n  for (const gindexBitstring of allBitstringsSorted) {\n    for (let i = 0; i < gindexBitstring.length; i++) {\n      if (gindexBitstring[gindexBitstring.length - 1 - i] === \"1\") {\n        descriptorBitstring += \"1\".padStart(i + 1, \"0\");\n        break;\n      }\n    }\n  }\n  // append zero bits to byte-alignt\n  if (descriptorBitstring.length % 8 != 0) {\n    descriptorBitstring = descriptorBitstring.padEnd(8 - descriptorBitstring.length % 8 + descriptorBitstring.length, \"0\");\n  }\n  // convert descriptor bitstring to bytes\n  const descriptor = new Uint8Array(descriptorBitstring.length / 8);\n  for (let i = 0; i < descriptor.length; i++) {\n    descriptor[i] = Number(\"0b\" + descriptorBitstring.substring(i * 8, (i + 1) * 8));\n  }\n  return descriptor;\n}\nexports.computeDescriptor = computeDescriptor;\nfunction getBit(bitlist, bitIndex) {\n  const bit = bitIndex % 8;\n  const byteIdx = Math.floor(bitIndex / 8);\n  const byte = bitlist[byteIdx];\n  switch (bit) {\n    case 0:\n      return (byte & 0b1000_0000) !== 0;\n    case 1:\n      return (byte & 0b0100_0000) !== 0;\n    case 2:\n      return (byte & 0b0010_0000) !== 0;\n    case 3:\n      return (byte & 0b0001_0000) !== 0;\n    case 4:\n      return (byte & 0b0000_1000) !== 0;\n    case 5:\n      return (byte & 0b0000_0100) !== 0;\n    case 6:\n      return (byte & 0b0000_0010) !== 0;\n    case 7:\n      return (byte & 0b0000_0001) !== 0;\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction descriptorToBitlist(descriptor) {\n  const bools = [];\n  const maxBitLength = descriptor.length * 8;\n  let count0 = 0;\n  let count1 = 0;\n  for (let i = 0; i < maxBitLength; i++) {\n    const bit = getBit(descriptor, i);\n    bools.push(bit);\n    if (bit) {\n      count1++;\n    } else {\n      count0++;\n    }\n    if (count1 > count0) {\n      i++;\n      if (i + 7 < maxBitLength) {\n        throw new Error(\"Invalid descriptor: too many bytes\");\n      }\n      for (; i < maxBitLength; i++) {\n        const bit = getBit(descriptor, i);\n        if (bit) {\n          throw new Error(\"Invalid descriptor: too many 1 bits\");\n        }\n      }\n      return bools;\n    }\n  }\n  throw new Error(\"Invalid descriptor: not enough 1 bits\");\n}\nexports.descriptorToBitlist = descriptorToBitlist;\nfunction nodeToCompactMultiProof(node, bitlist, bitIndex) {\n  if (bitlist[bitIndex]) {\n    return [node.root];\n  } else {\n    const left = nodeToCompactMultiProof(node.left, bitlist, bitIndex + 1);\n    const right = nodeToCompactMultiProof(node.right, bitlist, bitIndex + left.length * 2);\n    return [...left, ...right];\n  }\n}\nexports.nodeToCompactMultiProof = nodeToCompactMultiProof;\n/**\n * Create a Node given a validated bitlist, leaves, and a pointer into the bitlist and leaves\n *\n * Recursive definition\n */\nfunction compactMultiProofToNode(bitlist, leaves, pointer) {\n  if (bitlist[pointer.bitIndex++]) {\n    return node_1.LeafNode.fromRoot(leaves[pointer.leafIndex++]);\n  } else {\n    return new node_1.BranchNode(compactMultiProofToNode(bitlist, leaves, pointer), compactMultiProofToNode(bitlist, leaves, pointer));\n  }\n}\nexports.compactMultiProofToNode = compactMultiProofToNode;\nfunction createCompactMultiProof(rootNode, descriptor) {\n  return nodeToCompactMultiProof(rootNode, descriptorToBitlist(descriptor), 0);\n}\nexports.createCompactMultiProof = createCompactMultiProof;\nfunction createNodeFromCompactMultiProof(leaves, descriptor) {\n  const bools = descriptorToBitlist(descriptor);\n  if (bools.length !== leaves.length * 2 - 1) {\n    throw new Error(\"Invalid multiproof: invalid number of leaves\");\n  }\n  return compactMultiProofToNode(bools, leaves, {\n    bitIndex: 0,\n    leafIndex: 0\n  });\n}\nexports.createNodeFromCompactMultiProof = createNodeFromCompactMultiProof;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}