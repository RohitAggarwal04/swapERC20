{"ast":null,"code":"\"use strict\";\n\nvar _Object$keys = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs3/regenerator\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/asyncToGenerator\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseFileEncode = require(\"./ParseFileEncode\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys(object);\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context2, _context3;\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context2 = ownKeys(Object(source), !0)).call(_context2, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context3 = ownKeys(Object(source))).call(_context3, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar XHR = null;\nif (typeof XMLHttpRequest !== 'undefined') {\n  XHR = XMLHttpRequest;\n}\nvar DefaultController = {\n  saveFile: function () {\n    var _saveFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name\n    /*: string*/, source\n    /*: FileSource*/, options\n    /*:: ?: FullOptions*/) {\n      var base64Data, _base64Data$split, _base64Data$split2, first, second, data, newSource;\n      return _regenerator.default.wrap(function (_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(source.format !== 'file')) {\n                _context.next = 2;\n                break;\n              }\n              throw new Error('saveFile can only be used with File-type sources.');\n            case 2:\n              _context.next = 4;\n              return new _promise.default(function (res, rej) {\n                // eslint-disable-next-line no-undef\n                var reader = new FileReader();\n                reader.onload = function () {\n                  return res(reader.result);\n                };\n                reader.onerror = function (error) {\n                  return rej(error);\n                };\n                reader.readAsDataURL(source.file);\n              });\n            case 4:\n              base64Data = _context.sent; // we only want the data after the comma\n              // For example: \"data:application/pdf;base64,JVBERi0xLjQKJ...\" we would only want \"JVBERi0xLjQKJ...\"\n\n              _base64Data$split = base64Data.split(','), _base64Data$split2 = (0, _slicedToArray2.default)(_base64Data$split, 2), first = _base64Data$split2[0], second = _base64Data$split2[1]; // in the event there is no 'data:application/pdf;base64,' at the beginning of the base64 string\n              // use the entire string instead\n\n              data = second ? second : first;\n              newSource = {\n                format: 'base64',\n                base64: data,\n                type: source.type || (source.file ? source.file.type : null)\n              };\n              _context.next = 10;\n              return DefaultController.saveBase64(name, newSource, options);\n            case 10:\n              return _context.abrupt(\"return\", _context.sent);\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return function () {\n      return _saveFile.apply(this, arguments);\n    };\n  }(),\n  saveBase64: function (name\n  /*: string*/, source\n  /*: FileSource*/, options\n  /*:: ?: FullOptions*/) {\n    if (source.format !== 'base64') {\n      throw new Error('saveBase64 can only be used with Base64-type sources.');\n    }\n    var data\n    /*: { base64: any, _ContentType?: any, fileData: Object }*/ = {\n      base64: source.base64,\n      fileData: {\n        ipfs: options.ipfs,\n        metadata: _objectSpread({}, options.metadata),\n        tags: _objectSpread({}, options.tags)\n      }\n    };\n    delete options.metadata;\n    delete options.tags;\n    if (source.type) {\n      data._ContentType = source.type;\n    }\n    var path = \"files/\".concat(name);\n    return _CoreManager.default.getRESTController().request('POST', path, data, options);\n  },\n  download: function (uri, options) {\n    if (XHR) {\n      return this.downloadAjax(uri, options);\n    }\n    return _promise.default.reject('Cannot make a request: No definition of XMLHttpRequest was found.');\n  },\n  downloadAjax: function (uri, options) {\n    return new _promise.default(function (resolve, reject) {\n      var xhr = new XHR();\n      xhr.open('GET', uri, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onerror = function (e) {\n        reject(e);\n      };\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState !== xhr.DONE) {\n          return;\n        }\n        if (!this.response) {\n          return resolve({});\n        }\n        var bytes = new Uint8Array(this.response);\n        resolve({\n          base64: (0, _ParseFileEncode.encodeBase64)(bytes),\n          contentType: xhr.getResponseHeader('content-type')\n        });\n      };\n      options.requestTask(xhr);\n      xhr.send();\n    });\n  },\n  deleteFile: function (name\n  /*: string*/, options\n  /*:: ?: FullOptions*/) {\n    var headers = {\n      'X-Parse-Application-ID': _CoreManager.default.get('APPLICATION_ID')\n    };\n    if (options.useMasterKey) {\n      headers['X-Parse-Master-Key'] = _CoreManager.default.get('MASTER_KEY');\n    }\n    var url = _CoreManager.default.get('SERVER_URL');\n    if (url[url.length - 1] !== '/') {\n      url += '/';\n    }\n    url += \"files/\".concat(name);\n    return _CoreManager.default.getRESTController().ajax('DELETE', url, '', headers).catch(function (response) {\n      // TODO: return JSON object in server\n      if (!response || response === 'SyntaxError: Unexpected end of JSON input') {\n        return _promise.default.resolve();\n      }\n      return _CoreManager.default.getRESTController().handleError(response);\n    });\n  },\n  _setXHR: function (xhr\n  /*: any*/) {\n    XHR = xhr;\n  },\n  _getXHR: function () {\n    return XHR;\n  }\n};\nmodule.exports = DefaultController;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}